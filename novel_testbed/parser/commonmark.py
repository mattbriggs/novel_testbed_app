"""
CommonMark (Markdown) novel parser.

This parser consumes *segmented Markdown* produced by the segmentation stage.

It recognizes:
- Chapters starting with:    # Chapter Title
- Modules starting with:     ## Scene ..., ## Exposition ..., ## Transition ...

Each module is converted into a Module object with:
- type inference
- line anchors
- start and end text previews
- stable module IDs

This parser is intentionally strict. It assumes segmentation has already
inserted valid chapter and module markers. If no modules are found, the
segmentation stage failed or was skipped, and the pipeline is invalid.
"""

from __future__ import annotations

import logging
import re
from typing import List, Optional

from novel_testbed.models import Module, ModuleType, Novel
from novel_testbed.parser.base import NovelParser

logger = logging.getLogger(__name__)


class CommonMarkNovelParser(NovelParser):
    """
    Parser for CommonMark-style Markdown novels.

    This parser operates strictly on *annotated Markdown* generated by the
    segmentation stage. It does not attempt to infer structure from raw prose.

    Recognizes:
    - # Chapter headings
    - ## Module headings

    Module type is inferred from the first word of the module title:
    Scene, Exposition, Transition, or OTHER.
    """

    _re_chapter = re.compile(r"^#\s+(.+)$")
    _re_module = re.compile(r"^##\s+(.+)$")

    def parse(self, text: str, *, title: str) -> Novel:
        """
        Parse segmented CommonMark Markdown into a Novel model.

        Expected structure:

            # Chapter Title
            ## Scene ...
            ## Exposition ...
            ## Transition ...

        Everything between two module headers becomes one Module.

        :param text:
            Annotated Markdown text (output of the segmentation stage).
        :param title:
            Title of the novel.
        :return:
            Novel object containing parsed modules.
        """
        lines = text.splitlines()

        chapter: Optional[str] = None
        modules: List[Module] = []

        cur_title: Optional[str] = None
        cur_start: Optional[int] = None
        buf: List[str] = []

        def flush(end_line: int) -> None:
            """
            Finalize the current module buffer into a Module object.

            Guarantees:
            - Every module spans at least one line.
            - start_line < end_line is always true.

            This function is purely mechanical. It assumes the segmentation
            stage already created valid chapter and module boundaries.
            """
            nonlocal cur_title, cur_start, buf, chapter

            if cur_title is None or cur_start is None or chapter is None:
                buf = []
                cur_title = None
                cur_start = None
                return

            body = "\n".join(buf).strip("\n")
            nonempty = [ln for ln in body.splitlines() if ln.strip()]

            start_text = (nonempty[0] if nonempty else "")[:120]
            end_text = (nonempty[-1] if nonempty else "")[:120]

            first_word = cur_title.split()[0].lower() if cur_title else ""
            if first_word == "scene":
                mtype = ModuleType.SCENE
            elif first_word == "exposition":
                mtype = ModuleType.EXPOSITION
            elif first_word == "transition":
                mtype = ModuleType.TRANSITION
            else:
                mtype = ModuleType.OTHER

            module_id = f"M{len(modules) + 1:03d}"

            # Enforce invariant: modules must span at least one line
            actual_end = max(end_line, cur_start + 1)

            logger.debug(
                "Creating module %s: %s (%s) lines %dâ€“%d",
                module_id,
                cur_title,
                mtype.name,
                cur_start,
                actual_end,
            )

            modules.append(
                Module(
                    id=module_id,
                    chapter=chapter,
                    title=cur_title,
                    module_type=mtype,
                    start_line=cur_start,
                    end_line=actual_end,
                    text=body,
                    start_text=start_text,
                    end_text=end_text,
                )
            )

            buf = []
            cur_title = None
            cur_start = None

        for idx, line in enumerate(lines, start=1):
            m_chapter = self._re_chapter.match(line)
            m_module = self._re_module.match(line)

            if m_chapter:
                flush(idx - 1)
                chapter = m_chapter.group(1).strip()
                logger.debug("Found chapter: %s (line %d)", chapter, idx)
                continue

            if m_module:
                flush(idx - 1)
                cur_title = m_module.group(1).strip()
                cur_start = idx + 1
                buf = []
                logger.debug(
                    "Found module: %s (starts at line %d)",
                    cur_title,
                    cur_start,
                )
                continue

            if cur_title is not None:
                buf.append(line)

        flush(len(lines))

        if not modules:
            logger.error(
                "No modules parsed. This usually means the segmentation stage "
                "failed or was skipped. The parser requires annotated Markdown."
            )

        return Novel(title=title, modules=modules)